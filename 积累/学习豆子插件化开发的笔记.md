 # 一些概念
 * C++ 二进制兼容性问题 : 目前没有标准的C++ ABI  

<br/>

 * 插件管理器 : 能够发现、加载插件，执行初始化操作，注册工厂函数，也能够卸载插件。另外，它还应该能够允许 **主系统(主体程序)** 遍历已加载或者已注册的插件。插件管理器一般和主体程序写在一起。

 <br/>


 * 插件部署模型 : 插件通常以动态链接库的形式部署。动态链接库有很多好处，例如热切换（无需停止系统即可重新加载新的实现），由第三方开发者提供安全扩展（无需修改系统即可增加功能）和更短的链接时间。但是，也有一些情景是静态库更适合的。例如，有些系统根本不支持动态链接库（许多嵌入式系统都是这样的）。另外，基于安全原因，有些系统不允许加载外部代码。有时，核心系统需要预加载一些额外的插件，那么，使用静态链接的形式无疑更加健壮（这样的话，用户就不能随便删除这些文件了）。**最后，一个好的插件系统应当同时支持动态链接和静态链接的插件。这可以让你在不同的环境、不同的要求下使用同一套插件系统。**


<br/>


 &emsp;&emsp;所谓插件，其实就是基于接口的设计。基于插件的系统最基本的一点就是，要有一个中心系统，用于加载未知的插件，并且能够使用预先定义好的接口和协议与这些插件进行交互。最基本的方式是定义一个接口，提供一系列插件（动态的或者是静态）需要暴露出的函数。这种实现从技术上说是可行的，但实际并不那么简单地操作。原因在于，**一个插件需要支持两类接口**，但是却只能暴露出一个接口的函数集。这意味着，两类接口必须混合在一起。**第一个接口（协议）是通用插件接口。**该接口允许中心系统初始化插件，能够将插件提供的用于创建、销毁对象的函数注册给中心系统。这个通用插件接口不是特定领域相关的，因此能够作为一个可复用库。**第二个接口则是插件对象提供的功能接口。**这个接口是与特定领域相关的，必须被仔细地设计，并且由插件实际实现。中心系统应当利用这个接口与插件对象进行交互。


 <br/>

 ``` C++
//通用插件接口的头文件
#ifndef PF_PLUGIN_H
#define PF_PLUGIN_H

#include <apr-1/apr_general.h>

#ifdef __cplusplus
extern "C" {
#endif

//表明插件是由什么语言实现的
typedef enum PF_ProgrammingLanguage  
{
    PF_ProgrammingLanguage_C,
    PF_ProgrammingLanguage_CPP,
}   PF_ProgrammingLanguage;


struct PF_PlatformServices_;

//抽象结构
typedef struct PF_ObjectParams  
{
    const apr_byte_t * objectType;
    const struct PF_PlatformServices_ * platformServices;
} PF_ObjectParams;


//插件版本信息
typedef struct PF_PluginAPI_Version 
{
    apr_int32_t major;
    apr_int32_t minor;
} PF_PluginAPI_Version;



//以下两个函数指针 必须由插件实现，给插件管理器用的  创建和销毁插件对象
typedef void *      (*PF_CreateFunc)(PF_ObjectParams *); 
typedef apr_int32_t (*PF_DestroyFunc)(void *);

//插件的需要向插件管理器提供的信息
typedef struct PF_RegisterParams   
{
    PF_PluginAPI_Version version;   //版本
    PF_CreateFunc createFunc;       //创建插件的函数指针
    PF_DestroyFunc destroyFunc;     //销毁插件的函数指针
    PF_ProgrammingLanguage programmingLanguage; //开发语言
} PF_RegisterParams;

/*PF_RegisterFunc函数指针（由插件管理器实现）允许每个插件将其支持的对象类型以PF_RegisterParams结构的形式注册给插件管理器。
  注意，这种实现允许插件注册不同版本的对象，以及注册多个对象类型。
*/
typedef apr_int32_t (*PF_RegisterFunc)(const apr_byte_t * nodeType,const PF_RegisterParams * params);




/*
   调用服务函数
   允许插件调用主体程序提供的各种服务，例如日志、事件处理或错误报告等。。
*/
typedef apr_int32_t (*PF_InvokeServiceFunc)(const apr_byte_t * serviceName,void * serviceParams);

//PF_PlatformServices结构用于表示平台提供的所有服务（版本、已注册对象和调用函数）。该结构会在插件初始化的时候传给每一个插件。
typedef struct PF_PlatformServices
{
    PF_PluginAPI_Version version;
    PF_RegisterFunc registerObject;
    PF_InvokeServiceFunc invokeService;
} PF_PlatformServices;

//插件退出函数指针
typedef apr_int32_t (*PF_ExitFunc)();
//插件初始化函数指针
typedef PF_ExitFunc (*PF_InitFunc)(const PF_PlatformServices *);



#ifndef PLUGIN_API
  #ifdef WIN32
    #define PLUGIN_API __declspec(dllimport)
  #else
    #define PLUGIN_API
  #endif
#endif


//我感觉这下面的代码没用啊先注释了
// extern
// #ifdef  __cplusplus
// "C"
// #endif


/*
PF_initPlugin是动态插件（也就是通过动态链接库或者共享库部署的插件）初始化函数的实际声明。它由动态插件暴露出，所以插件管理器可以在加载插件时进行调用。它有一个指向PF_PlatformServices结构的指针，所以在插件初始化时，这些服务都是可以调用的（这正是注册对象的理想时机），函数返回退出函数的指针。

而对于静态插件（由静态链接库实现，并且直接与主应用程序链接的插件）应该实现init函数，但是不能命名为PF_initPlugin。原因是，如果有多个静态插件，它们不能有相同的名字的函数。
 */
PLUGIN_API PF_ExitFunc PF_initPlugin(const PF_PlatformServices * params);

#ifdef  __cplusplus
}
#endif


&emsp;&emsp;从这个通用插件接口头文件中可以看出包括几个部分 
* 插件的开发语言
* 




#endif /* PF_PLUGIN_H */
 ```


# 面向对象的 C 语言设计

 ``` C++
#ifndef C_OBJECT_MODEL
#define C_OBJECT_MODEL

#include <apr-1/apr.h>

#define MAX_STR 64 /* max string length of string fields */

typedef struct C_ActorInfo_
{
    apr_uint32_t id;
    apr_byte_t   name[MAX_STR];
    apr_uint32_t location_x;
    apr_uint32_t location_y;
    apr_uint32_t health;
    apr_uint32_t attack;
    apr_uint32_t defense;
    apr_uint32_t damage;
    apr_uint32_t movement;
} C_ActorInfo;  //一个游戏角色信息的结构体

//这是typedef了一个结构体指针吗
typedef struct C_ActorInfoIteratorHandle_ { char c; } * C_ActorInfoIteratorHandle;
typedef struct C_ActorInfoIterator_
{
  void (*reset)(C_ActorInfoIteratorHandle handle);
  C_ActorInfo * (*next)(C_ActorInfoIteratorHandle handle);

  C_ActorInfoIteratorHandle handle;
} C_ActorInfoIterator;


typedef struct C_TurnHandle_ { char c; } * C_TurnHandle;
typedef struct C_Turn_
{
  C_ActorInfo * (*getSelfInfo)(C_TurnHandle handle);
  C_ActorInfoIterator * (*getFriends)(C_TurnHandle handle);
  C_ActorInfoIterator * (*getFoes)(C_TurnHandle handle);

  void (*move)(C_TurnHandle handle, apr_uint32_t x, apr_uint32_t y);
  void (*attack)(C_TurnHandle handle, apr_uint32_t id);

  C_TurnHandle handle;
} C_Turn;


typedef struct C_ActorHandle_ { char c; } * C_ActorHandle;
typedef struct C_Actor_
{
    void (*getInitialInfo)(C_ActorHandle handle, C_ActorInfo * info);
    void (*play)(C_ActorHandle handle, C_Turn * turn); 

    C_ActorHandle handle;
} C_Actor;

#endif
 ```







&emsp;&emsp;这个在后面应该会用到

``` C++ 
 struct IActor
{
    virtual ~IActor() {}
    virtual void getInitialInfo(ActorInfo * info) = 0;
    virtual void play( ITurn * turnInfo) = 0;
};
```



# 加载动态插件
&emsp;&emsp;动态插件当然更常见。动态插件应该都部署在一个专门的目录中。应用程序应该调用PluginManager的loadAll()函数，同时要将这个目录的路径传过去。PluginManager需要扫描该目录中的所有文件，然后将每一个动态链接库加载进来。如果系统需要细粒度地控制插件加载，程序可能还需要另外调用load()函数。