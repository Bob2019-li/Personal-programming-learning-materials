这是我第三遍看这个笔记了，这次一定要坚持下来，一定要看完


# 通用插件接口的头文件

``` C++
#ifndef PF_PLUGIN_H
#define PF_PLUGIN_H

#include <apr-1/apr_general.h>

#ifdef __cplusplus
extern "C" {
#endif

//允许插件告诉插件管理器 插件实现的语言类型
typedef enum PF_ProgrammingLanguage
{
  PF_ProgrammingLanguage_C,
  PF_ProgrammingLanguage_CPP
} PF_ProgrammingLanguage;

 //向前置声明，不知道为啥要这么做
struct PF_PlatformServices;

 //平台在创建插件对象时传入的信息
typedef struct PF_ObjectParams
{
  const apr_byte_t * objectType;  //对象类型
  const struct PF_PlatformServices * platformServices; //平台服务信息
} PF_ObjectParams;

//插件版本
typedef struct PF_PluginAPI_Version
{
  apr_int32_t major;
  apr_int32_t minor;
} PF_PluginAPI_Version;

typedef void * (*PF_CreateFunc)(PF_ObjectParams *);  //创建插件对象 这是插件自己使用的 这里用到了 PF_ObjectParams 结构体
typedef apr_int32_t (*PF_DestroyFunc)(void *);       //销毁插件对象 这是插件自己使用的 

//插件向插件管理器注册的结构体
typedef struct PF_RegisterParams
{
  PF_PluginAPI_Version version;
  PF_CreateFunc createFunc;       //插件的创建函数
  PF_DestroyFunc destroyFunc;     //插件的销毁函数
  PF_ProgrammingLanguage programmingLanguage;
} PF_RegisterParams;

//注册函数  这个应该是插件调用  由插件管理器实现
typedef apr_int32_t (*PF_RegisterFunc)(const apr_byte_t * nodeType, const PF_RegisterParams * params);

//调用服务函数  这个也应该是插件调用  由插件管理器实现
/*
   PF_InvokeService函数指针是一个通用函数，允许插件调用主系统提供的各种服务，例如日志、事件处理或者错误报告等。
   该函数要求有一个服务名称以及一个指向参数结构的不透明的指针。
   插件应当知道可用的服务以及如何调用它们（或者实现一种服务发现机制）。
 */
typedef apr_int32_t (*PF_InvokeServiceFunc)(const apr_byte_t * serviceName, void * serviceParams);

typedef struct PF_PlatformServices
{
  PF_PluginAPI_Version version;
  PF_RegisterFunc registerObject; 
  PF_InvokeServiceFunc invokeService; 
} PF_PlatformServices;


//插件退出函数
typedef apr_int32_t (*PF_ExitFunc)();


//插件初始化函数
/** Type definition of the PF_initPlugin function bellow (used by PluginManager to initialize plugins)
 * Note the return type is the PF_ExitFunc (used by PluginManager to tell plugins to cleanup). If 
 * the initialization failed for any reason the plugin may report the error via the error reporting
 * function of the provided platform services. Nevertheless, it must return NULL exit func in this case
 * to let the plugin manger that the plugin wasn't initialized properly. The plugin may use the runtime
 * services - allocate memory, log messages and of course register node types.
 *
 * @param  [const PF_PlatformServices *] params - the platform services struct 
 * @retval [PF_ExitFunc] the exit func of the plugin or NULL if initialization failed.
 */
typedef PF_ExitFunc (*PF_InitFunc)(const PF_PlatformServices *);




/**  这是动态导出函数   初始化插件  PF_InitFunc 和 PF_initPlugin 有点关系
 * Named exported entry point into the plugin
 * This definition is required eventhough the function 
 * is loaded from a dynamic library by name
 * and casted to PF_InitFunc. If this declaration is 
 * commented out DynamicLibrary::getSymbol() fails
 *
 * The plugin's initialization function MUST be called "PF_initPlugin"
 * (and conform to the signature of course).
 *
 * @param  [const PF_PlatformServices *] params - the platform services struct 
 * @retval [PF_ExitFunc] the exit func of the plugin or NULL if initialization failed.
 */

#ifndef PLUGIN_API
  #ifdef WIN32
    #define PLUGIN_API __declspec(dllimport)
  #else
    #define PLUGIN_API
  #endif
#endif

extern
#ifdef  __cplusplus
"C" 
#endif
PLUGIN_API PF_ExitFunc PF_initPlugin(const PF_PlatformServices * params);

#ifdef  __cplusplus
}
#endif

#endif /* PF_PLUGIN_H */

```

有几个疑问
1. 插件怎么知道 平台提供哪些服务？？？？？
2. 插件初始化 和 退出 函数应该是插件管理器调用的吧？
3. PF_InitFunc 和  PF_initPlugin 的关系，我看返回值和形参都是一样的，而且从注释中也觉得不一般


